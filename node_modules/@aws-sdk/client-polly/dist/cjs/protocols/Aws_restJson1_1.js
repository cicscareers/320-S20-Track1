"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
async function serializeAws_restJson1_1DeleteLexiconCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/lexicons/{Name}";
    if (input.Name !== undefined) {
        const labelValue = input.Name;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: Name.");
        }
        resolvedPath = resolvedPath.replace("{Name}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: Name.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "DELETE", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1DeleteLexiconCommand = serializeAws_restJson1_1DeleteLexiconCommand;
async function serializeAws_restJson1_1DescribeVoicesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/voices";
    const query = {};
    if (input.Engine !== undefined) {
        query["Engine"] = input.Engine;
    }
    if (input.IncludeAdditionalLanguageCodes !== undefined) {
        query["IncludeAdditionalLanguageCodes"] = input.IncludeAdditionalLanguageCodes.toString();
    }
    if (input.LanguageCode !== undefined) {
        query["LanguageCode"] = input.LanguageCode;
    }
    if (input.NextToken !== undefined) {
        query["NextToken"] = input.NextToken;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1DescribeVoicesCommand = serializeAws_restJson1_1DescribeVoicesCommand;
async function serializeAws_restJson1_1GetLexiconCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/lexicons/{Name}";
    if (input.Name !== undefined) {
        const labelValue = input.Name;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: Name.");
        }
        resolvedPath = resolvedPath.replace("{Name}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: Name.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetLexiconCommand = serializeAws_restJson1_1GetLexiconCommand;
async function serializeAws_restJson1_1GetSpeechSynthesisTaskCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/synthesisTasks/{TaskId}";
    if (input.TaskId !== undefined) {
        const labelValue = input.TaskId;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: TaskId.");
        }
        resolvedPath = resolvedPath.replace("{TaskId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: TaskId.");
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1GetSpeechSynthesisTaskCommand = serializeAws_restJson1_1GetSpeechSynthesisTaskCommand;
async function serializeAws_restJson1_1ListLexiconsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/lexicons";
    const query = {};
    if (input.NextToken !== undefined) {
        query["NextToken"] = input.NextToken;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1ListLexiconsCommand = serializeAws_restJson1_1ListLexiconsCommand;
async function serializeAws_restJson1_1ListSpeechSynthesisTasksCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "";
    let resolvedPath = "/v1/synthesisTasks";
    const query = {};
    if (input.MaxResults !== undefined) {
        query["MaxResults"] = input.MaxResults.toString();
    }
    if (input.NextToken !== undefined) {
        query["NextToken"] = input.NextToken;
    }
    if (input.Status !== undefined) {
        query["Status"] = input.Status;
    }
    let body;
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "GET", headers: headers, path: resolvedPath, query: query, body: body }));
}
exports.serializeAws_restJson1_1ListSpeechSynthesisTasksCommand = serializeAws_restJson1_1ListSpeechSynthesisTasksCommand;
async function serializeAws_restJson1_1PutLexiconCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/lexicons/{Name}";
    if (input.Name !== undefined) {
        const labelValue = input.Name;
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: Name.");
        }
        resolvedPath = resolvedPath.replace("{Name}", smithy_client_1.extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: Name.");
    }
    let body;
    const bodyParams = {};
    if (input.Content !== undefined) {
        bodyParams["Content"] = input.Content;
    }
    body = JSON.stringify(bodyParams);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "PUT", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1PutLexiconCommand = serializeAws_restJson1_1PutLexiconCommand;
async function serializeAws_restJson1_1StartSpeechSynthesisTaskCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/synthesisTasks";
    let body;
    const bodyParams = {};
    if (input.Engine !== undefined) {
        bodyParams["Engine"] = input.Engine;
    }
    if (input.LanguageCode !== undefined) {
        bodyParams["LanguageCode"] = input.LanguageCode;
    }
    if (input.LexiconNames !== undefined) {
        bodyParams["LexiconNames"] = serializeAws_restJson1_1LexiconNameList(input.LexiconNames, context);
    }
    if (input.OutputFormat !== undefined) {
        bodyParams["OutputFormat"] = input.OutputFormat;
    }
    if (input.OutputS3BucketName !== undefined) {
        bodyParams["OutputS3BucketName"] = input.OutputS3BucketName;
    }
    if (input.OutputS3KeyPrefix !== undefined) {
        bodyParams["OutputS3KeyPrefix"] = input.OutputS3KeyPrefix;
    }
    if (input.SampleRate !== undefined) {
        bodyParams["SampleRate"] = input.SampleRate;
    }
    if (input.SnsTopicArn !== undefined) {
        bodyParams["SnsTopicArn"] = input.SnsTopicArn;
    }
    if (input.SpeechMarkTypes !== undefined) {
        bodyParams["SpeechMarkTypes"] = serializeAws_restJson1_1SpeechMarkTypeList(input.SpeechMarkTypes, context);
    }
    if (input.Text !== undefined) {
        bodyParams["Text"] = input.Text;
    }
    if (input.TextType !== undefined) {
        bodyParams["TextType"] = input.TextType;
    }
    if (input.VoiceId !== undefined) {
        bodyParams["VoiceId"] = input.VoiceId;
    }
    body = JSON.stringify(bodyParams);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1StartSpeechSynthesisTaskCommand = serializeAws_restJson1_1StartSpeechSynthesisTaskCommand;
async function serializeAws_restJson1_1SynthesizeSpeechCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/json";
    let resolvedPath = "/v1/speech";
    let body;
    const bodyParams = {};
    if (input.Engine !== undefined) {
        bodyParams["Engine"] = input.Engine;
    }
    if (input.LanguageCode !== undefined) {
        bodyParams["LanguageCode"] = input.LanguageCode;
    }
    if (input.LexiconNames !== undefined) {
        bodyParams["LexiconNames"] = serializeAws_restJson1_1LexiconNameList(input.LexiconNames, context);
    }
    if (input.OutputFormat !== undefined) {
        bodyParams["OutputFormat"] = input.OutputFormat;
    }
    if (input.SampleRate !== undefined) {
        bodyParams["SampleRate"] = input.SampleRate;
    }
    if (input.SpeechMarkTypes !== undefined) {
        bodyParams["SpeechMarkTypes"] = serializeAws_restJson1_1SpeechMarkTypeList(input.SpeechMarkTypes, context);
    }
    if (input.Text !== undefined) {
        bodyParams["Text"] = input.Text;
    }
    if (input.TextType !== undefined) {
        bodyParams["TextType"] = input.TextType;
    }
    if (input.VoiceId !== undefined) {
        bodyParams["VoiceId"] = input.VoiceId;
    }
    body = JSON.stringify(bodyParams);
    return new protocol_http_1.HttpRequest(Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", headers: headers, path: resolvedPath, body: body }));
}
exports.serializeAws_restJson1_1SynthesizeSpeechCommand = serializeAws_restJson1_1SynthesizeSpeechCommand;
async function deserializeAws_restJson1_1DeleteLexiconCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DeleteLexiconCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DeleteLexiconOutput"
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DeleteLexiconCommand = deserializeAws_restJson1_1DeleteLexiconCommand;
async function deserializeAws_restJson1_1DeleteLexiconCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LexiconNotFoundException":
        case "com.amazonaws.parrot.v1#LexiconNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1LexiconNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1DescribeVoicesCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1DescribeVoicesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "DescribeVoicesOutput",
        NextToken: undefined,
        Voices: undefined
    };
    const data = await parseBody(output.body, context);
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = data.NextToken;
    }
    if (data.Voices !== undefined && data.Voices !== null) {
        contents.Voices = deserializeAws_restJson1_1VoiceList(data.Voices, context);
    }
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1DescribeVoicesCommand = deserializeAws_restJson1_1DescribeVoicesCommand;
async function deserializeAws_restJson1_1DescribeVoicesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.parrot.v1#InvalidNextTokenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetLexiconCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetLexiconCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetLexiconOutput",
        Lexicon: undefined,
        LexiconAttributes: undefined
    };
    const data = await parseBody(output.body, context);
    if (data.Lexicon !== undefined && data.Lexicon !== null) {
        contents.Lexicon = deserializeAws_restJson1_1Lexicon(data.Lexicon, context);
    }
    if (data.LexiconAttributes !== undefined && data.LexiconAttributes !== null) {
        contents.LexiconAttributes = deserializeAws_restJson1_1LexiconAttributes(data.LexiconAttributes, context);
    }
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetLexiconCommand = deserializeAws_restJson1_1GetLexiconCommand;
async function deserializeAws_restJson1_1GetLexiconCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LexiconNotFoundException":
        case "com.amazonaws.parrot.v1#LexiconNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1LexiconNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1GetSpeechSynthesisTaskCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1GetSpeechSynthesisTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "GetSpeechSynthesisTaskOutput",
        SynthesisTask: undefined
    };
    const data = await parseBody(output.body, context);
    if (data.SynthesisTask !== undefined && data.SynthesisTask !== null) {
        contents.SynthesisTask = deserializeAws_restJson1_1SynthesisTask(data.SynthesisTask, context);
    }
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1GetSpeechSynthesisTaskCommand = deserializeAws_restJson1_1GetSpeechSynthesisTaskCommand;
async function deserializeAws_restJson1_1GetSpeechSynthesisTaskCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidTaskIdException":
        case "com.amazonaws.parrot.v1#InvalidTaskIdException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidTaskIdExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "SynthesisTaskNotFoundException":
        case "com.amazonaws.parrot.v1#SynthesisTaskNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1SynthesisTaskNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1ListLexiconsCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1ListLexiconsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "ListLexiconsOutput",
        Lexicons: undefined,
        NextToken: undefined
    };
    const data = await parseBody(output.body, context);
    if (data.Lexicons !== undefined && data.Lexicons !== null) {
        contents.Lexicons = deserializeAws_restJson1_1LexiconDescriptionList(data.Lexicons, context);
    }
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = data.NextToken;
    }
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1ListLexiconsCommand = deserializeAws_restJson1_1ListLexiconsCommand;
async function deserializeAws_restJson1_1ListLexiconsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.parrot.v1#InvalidNextTokenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1ListSpeechSynthesisTasksCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1ListSpeechSynthesisTasksCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "ListSpeechSynthesisTasksOutput",
        NextToken: undefined,
        SynthesisTasks: undefined
    };
    const data = await parseBody(output.body, context);
    if (data.NextToken !== undefined && data.NextToken !== null) {
        contents.NextToken = data.NextToken;
    }
    if (data.SynthesisTasks !== undefined && data.SynthesisTasks !== null) {
        contents.SynthesisTasks = deserializeAws_restJson1_1SynthesisTasks(data.SynthesisTasks, context);
    }
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1ListSpeechSynthesisTasksCommand = deserializeAws_restJson1_1ListSpeechSynthesisTasksCommand;
async function deserializeAws_restJson1_1ListSpeechSynthesisTasksCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.parrot.v1#InvalidNextTokenException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1PutLexiconCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1PutLexiconCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "PutLexiconOutput"
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1PutLexiconCommand = deserializeAws_restJson1_1PutLexiconCommand;
async function deserializeAws_restJson1_1PutLexiconCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidLexiconException":
        case "com.amazonaws.parrot.v1#InvalidLexiconException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidLexiconExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "LexiconSizeExceededException":
        case "com.amazonaws.parrot.v1#LexiconSizeExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1LexiconSizeExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MaxLexemeLengthExceededException":
        case "com.amazonaws.parrot.v1#MaxLexemeLengthExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MaxLexemeLengthExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MaxLexiconsNumberExceededException":
        case "com.amazonaws.parrot.v1#MaxLexiconsNumberExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MaxLexiconsNumberExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedPlsAlphabetException":
        case "com.amazonaws.parrot.v1#UnsupportedPlsAlphabetException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1UnsupportedPlsAlphabetExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "UnsupportedPlsLanguageException":
        case "com.amazonaws.parrot.v1#UnsupportedPlsLanguageException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1UnsupportedPlsLanguageExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1StartSpeechSynthesisTaskCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1StartSpeechSynthesisTaskCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "StartSpeechSynthesisTaskOutput",
        SynthesisTask: undefined
    };
    const data = await parseBody(output.body, context);
    if (data.SynthesisTask !== undefined && data.SynthesisTask !== null) {
        contents.SynthesisTask = deserializeAws_restJson1_1SynthesisTask(data.SynthesisTask, context);
    }
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1StartSpeechSynthesisTaskCommand = deserializeAws_restJson1_1StartSpeechSynthesisTaskCommand;
async function deserializeAws_restJson1_1StartSpeechSynthesisTaskCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EngineNotSupportedException":
        case "com.amazonaws.parrot.v1#EngineNotSupportedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1EngineNotSupportedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidS3BucketException":
        case "com.amazonaws.parrot.v1#InvalidS3BucketException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidS3BucketExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidS3KeyException":
        case "com.amazonaws.parrot.v1#InvalidS3KeyException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidS3KeyExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidSampleRateException":
        case "com.amazonaws.parrot.v1#InvalidSampleRateException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidSampleRateExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidSnsTopicArnException":
        case "com.amazonaws.parrot.v1#InvalidSnsTopicArnException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidSnsTopicArnExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidSsmlException":
        case "com.amazonaws.parrot.v1#InvalidSsmlException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidSsmlExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "LanguageNotSupportedException":
        case "com.amazonaws.parrot.v1#LanguageNotSupportedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1LanguageNotSupportedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "LexiconNotFoundException":
        case "com.amazonaws.parrot.v1#LexiconNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1LexiconNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MarksNotSupportedForFormatException":
        case "com.amazonaws.parrot.v1#MarksNotSupportedForFormatException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MarksNotSupportedForFormatExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "SsmlMarksNotSupportedForTextTypeException":
        case "com.amazonaws.parrot.v1#SsmlMarksNotSupportedForTextTypeException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1SsmlMarksNotSupportedForTextTypeExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextLengthExceededException":
        case "com.amazonaws.parrot.v1#TextLengthExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TextLengthExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_restJson1_1SynthesizeSpeechCommand(output, context) {
    if (output.statusCode !== 200 && output.statusCode >= 400) {
        return deserializeAws_restJson1_1SynthesizeSpeechCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        __type: "SynthesizeSpeechOutput",
        AudioStream: undefined,
        ContentType: undefined,
        RequestCharacters: undefined
    };
    if (output.headers["content-type"] !== undefined) {
        contents.ContentType = output.headers["content-type"];
    }
    if (output.headers["x-amzn-requestcharacters"] !== undefined) {
        contents.RequestCharacters = parseInt(output.headers["x-amzn-requestcharacters"], 10);
    }
    const data = output.body;
    contents.AudioStream = data;
    return Promise.resolve(contents);
}
exports.deserializeAws_restJson1_1SynthesizeSpeechCommand = deserializeAws_restJson1_1SynthesizeSpeechCommand;
async function deserializeAws_restJson1_1SynthesizeSpeechCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EngineNotSupportedException":
        case "com.amazonaws.parrot.v1#EngineNotSupportedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1EngineNotSupportedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidSampleRateException":
        case "com.amazonaws.parrot.v1#InvalidSampleRateException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidSampleRateExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "InvalidSsmlException":
        case "com.amazonaws.parrot.v1#InvalidSsmlException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1InvalidSsmlExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "LanguageNotSupportedException":
        case "com.amazonaws.parrot.v1#LanguageNotSupportedException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1LanguageNotSupportedExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "LexiconNotFoundException":
        case "com.amazonaws.parrot.v1#LexiconNotFoundException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1LexiconNotFoundExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "MarksNotSupportedForFormatException":
        case "com.amazonaws.parrot.v1#MarksNotSupportedForFormatException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1MarksNotSupportedForFormatExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "ServiceFailureException":
        case "com.amazonaws.parrot.v1#ServiceFailureException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1ServiceFailureExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "SsmlMarksNotSupportedForTextTypeException":
        case "com.amazonaws.parrot.v1#SsmlMarksNotSupportedForTextTypeException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1SsmlMarksNotSupportedForTextTypeExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        case "TextLengthExceededException":
        case "com.amazonaws.parrot.v1#TextLengthExceededException":
            response = Object.assign(Object.assign({}, (await deserializeAws_restJson1_1TextLengthExceededExceptionResponse(parsedOutput, context))), { name: errorCode, $metadata: deserializeMetadata(output) });
            break;
        default:
            const parsedBody = parsedOutput.body;
            errorCode = parsedBody.code || parsedBody.Code || errorCode;
            response = Object.assign(Object.assign({}, parsedBody), { name: `${errorCode}`, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
const deserializeAws_restJson1_1EngineNotSupportedExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "EngineNotSupportedException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1InvalidLexiconExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidLexiconException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1InvalidNextTokenExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidNextTokenException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1InvalidS3BucketExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidS3BucketException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1InvalidS3KeyExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidS3KeyException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1InvalidSampleRateExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidSampleRateException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1InvalidSnsTopicArnExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidSnsTopicArnException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1InvalidSsmlExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidSsmlException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1InvalidTaskIdExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "InvalidTaskIdException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1LanguageNotSupportedExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "LanguageNotSupportedException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1LexiconNotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "LexiconNotFoundException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1LexiconSizeExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "LexiconSizeExceededException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1MarksNotSupportedForFormatExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "MarksNotSupportedForFormatException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1MaxLexemeLengthExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "MaxLexemeLengthExceededException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1MaxLexiconsNumberExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "MaxLexiconsNumberExceededException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1ServiceFailureExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "ServiceFailureException",
        $fault: "server",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1SsmlMarksNotSupportedForTextTypeExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "SsmlMarksNotSupportedForTextTypeException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1SynthesisTaskNotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "SynthesisTaskNotFoundException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1TextLengthExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "TextLengthExceededException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1UnsupportedPlsAlphabetExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "UnsupportedPlsAlphabetException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const deserializeAws_restJson1_1UnsupportedPlsLanguageExceptionResponse = async (parsedOutput, context) => {
    const contents = {
        name: "UnsupportedPlsLanguageException",
        $fault: "client",
        $metadata: deserializeMetadata(parsedOutput),
        message: undefined
    };
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = data.message;
    }
    return contents;
};
const serializeAws_restJson1_1LexiconNameList = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(entry);
    }
    return contents;
};
const serializeAws_restJson1_1SpeechMarkTypeList = (input, context) => {
    const contents = [];
    for (let entry of input) {
        contents.push(entry);
    }
    return contents;
};
const deserializeAws_restJson1_1EngineList = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_restJson1_1LanguageCodeList = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_restJson1_1Lexicon = (output, context) => {
    let contents = {
        __type: "Lexicon",
        Content: undefined,
        Name: undefined
    };
    if (output.Content !== undefined && output.Content !== null) {
        contents.Content = output.Content;
    }
    if (output.Name !== undefined && output.Name !== null) {
        contents.Name = output.Name;
    }
    return contents;
};
const deserializeAws_restJson1_1LexiconAttributes = (output, context) => {
    let contents = {
        __type: "LexiconAttributes",
        Alphabet: undefined,
        LanguageCode: undefined,
        LastModified: undefined,
        LexemesCount: undefined,
        LexiconArn: undefined,
        Size: undefined
    };
    if (output.Alphabet !== undefined && output.Alphabet !== null) {
        contents.Alphabet = output.Alphabet;
    }
    if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
        contents.LanguageCode = output.LanguageCode;
    }
    if (output.LastModified !== undefined && output.LastModified !== null) {
        contents.LastModified = new Date(Math.round(output.LastModified * 1000));
    }
    if (output.LexemesCount !== undefined && output.LexemesCount !== null) {
        contents.LexemesCount = output.LexemesCount;
    }
    if (output.LexiconArn !== undefined && output.LexiconArn !== null) {
        contents.LexiconArn = output.LexiconArn;
    }
    if (output.Size !== undefined && output.Size !== null) {
        contents.Size = output.Size;
    }
    return contents;
};
const deserializeAws_restJson1_1LexiconDescription = (output, context) => {
    let contents = {
        __type: "LexiconDescription",
        Attributes: undefined,
        Name: undefined
    };
    if (output.Attributes !== undefined && output.Attributes !== null) {
        contents.Attributes = deserializeAws_restJson1_1LexiconAttributes(output.Attributes, context);
    }
    if (output.Name !== undefined && output.Name !== null) {
        contents.Name = output.Name;
    }
    return contents;
};
const deserializeAws_restJson1_1LexiconDescriptionList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1LexiconDescription(entry, context));
};
const deserializeAws_restJson1_1LexiconNameList = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_restJson1_1SpeechMarkTypeList = (output, context) => {
    return (output || []).map((entry) => entry);
};
const deserializeAws_restJson1_1SynthesisTask = (output, context) => {
    let contents = {
        __type: "SynthesisTask",
        CreationTime: undefined,
        Engine: undefined,
        LanguageCode: undefined,
        LexiconNames: undefined,
        OutputFormat: undefined,
        OutputUri: undefined,
        RequestCharacters: undefined,
        SampleRate: undefined,
        SnsTopicArn: undefined,
        SpeechMarkTypes: undefined,
        TaskId: undefined,
        TaskStatus: undefined,
        TaskStatusReason: undefined,
        TextType: undefined,
        VoiceId: undefined
    };
    if (output.CreationTime !== undefined && output.CreationTime !== null) {
        contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
    }
    if (output.Engine !== undefined && output.Engine !== null) {
        contents.Engine = output.Engine;
    }
    if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
        contents.LanguageCode = output.LanguageCode;
    }
    if (output.LexiconNames !== undefined && output.LexiconNames !== null) {
        contents.LexiconNames = deserializeAws_restJson1_1LexiconNameList(output.LexiconNames, context);
    }
    if (output.OutputFormat !== undefined && output.OutputFormat !== null) {
        contents.OutputFormat = output.OutputFormat;
    }
    if (output.OutputUri !== undefined && output.OutputUri !== null) {
        contents.OutputUri = output.OutputUri;
    }
    if (output.RequestCharacters !== undefined &&
        output.RequestCharacters !== null) {
        contents.RequestCharacters = output.RequestCharacters;
    }
    if (output.SampleRate !== undefined && output.SampleRate !== null) {
        contents.SampleRate = output.SampleRate;
    }
    if (output.SnsTopicArn !== undefined && output.SnsTopicArn !== null) {
        contents.SnsTopicArn = output.SnsTopicArn;
    }
    if (output.SpeechMarkTypes !== undefined && output.SpeechMarkTypes !== null) {
        contents.SpeechMarkTypes = deserializeAws_restJson1_1SpeechMarkTypeList(output.SpeechMarkTypes, context);
    }
    if (output.TaskId !== undefined && output.TaskId !== null) {
        contents.TaskId = output.TaskId;
    }
    if (output.TaskStatus !== undefined && output.TaskStatus !== null) {
        contents.TaskStatus = output.TaskStatus;
    }
    if (output.TaskStatusReason !== undefined &&
        output.TaskStatusReason !== null) {
        contents.TaskStatusReason = output.TaskStatusReason;
    }
    if (output.TextType !== undefined && output.TextType !== null) {
        contents.TextType = output.TextType;
    }
    if (output.VoiceId !== undefined && output.VoiceId !== null) {
        contents.VoiceId = output.VoiceId;
    }
    return contents;
};
const deserializeAws_restJson1_1SynthesisTasks = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1SynthesisTask(entry, context));
};
const deserializeAws_restJson1_1Voice = (output, context) => {
    let contents = {
        __type: "Voice",
        AdditionalLanguageCodes: undefined,
        Gender: undefined,
        Id: undefined,
        LanguageCode: undefined,
        LanguageName: undefined,
        Name: undefined,
        SupportedEngines: undefined
    };
    if (output.AdditionalLanguageCodes !== undefined &&
        output.AdditionalLanguageCodes !== null) {
        contents.AdditionalLanguageCodes = deserializeAws_restJson1_1LanguageCodeList(output.AdditionalLanguageCodes, context);
    }
    if (output.Gender !== undefined && output.Gender !== null) {
        contents.Gender = output.Gender;
    }
    if (output.Id !== undefined && output.Id !== null) {
        contents.Id = output.Id;
    }
    if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
        contents.LanguageCode = output.LanguageCode;
    }
    if (output.LanguageName !== undefined && output.LanguageName !== null) {
        contents.LanguageName = output.LanguageName;
    }
    if (output.Name !== undefined && output.Name !== null) {
        contents.Name = output.Name;
    }
    if (output.SupportedEngines !== undefined &&
        output.SupportedEngines !== null) {
        contents.SupportedEngines = deserializeAws_restJson1_1EngineList(output.SupportedEngines, context);
    }
    return contents;
};
const deserializeAws_restJson1_1VoiceList = (output, context) => {
    return (output || []).map((entry) => deserializeAws_restJson1_1Voice(entry, context));
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    httpHeaders: output.headers,
    requestId: output.headers["x-amzn-requestid"]
});
// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody, context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return (context.streamCollector(streamBody) || Promise.resolve(new Uint8Array()));
};
// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody, context) => {
    return collectBody(streamBody, context).then(body => context.utf8Encoder(body));
};
const parseBody = (streamBody, context) => {
    return collectBodyString(streamBody, context).then(encoded => {
        if (encoded.length) {
            return JSON.parse(encoded);
        }
        return {};
    });
};
/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find(k => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
    return "";
};
//# sourceMappingURL=Aws_restJson1_1.js.map